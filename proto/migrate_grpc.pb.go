// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v6.33.2
// source: proto/migrate.proto

package migrate

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	MigrationService_TransferVolume_FullMethodName      = "/migrate.MigrationService/TransferVolume"
	MigrationService_TransferImageLayers_FullMethodName = "/migrate.MigrationService/TransferImageLayers"
	MigrationService_GetResourceList_FullMethodName     = "/migrate.MigrationService/GetResourceList"
	MigrationService_Ping_FullMethodName                = "/migrate.MigrationService/Ping"
	MigrationService_TransferContainer_FullMethodName   = "/migrate.MigrationService/TransferContainer"
	MigrationService_TransferNetwork_FullMethodName     = "/migrate.MigrationService/TransferNetwork"
)

// MigrationServiceClient is the client API for MigrationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MigrationService handles peer-to-peer resource migration
type MigrationServiceClient interface {
	// TransferVolume transfers volume data in chunks with checksums
	TransferVolume(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VolumeChunk, TransferAck], error)
	// TransferImageLayers transfers image layers as blobs
	TransferImageLayers(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LayerBlob, TransferAck], error)
	// GetResourceList retrieves list of available resources on peer
	GetResourceList(ctx context.Context, in *ResourceRequest, opts ...grpc.CallOption) (*ResourceList, error)
	// Ping checks peer connectivity and latency
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Pong, error)
	// TransferContainer transfers container state and configuration
	TransferContainer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ContainerChunk, TransferAck], error)
	// TransferNetwork transfers network configuration
	TransferNetwork(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*TransferResult, error)
}

type migrationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMigrationServiceClient(cc grpc.ClientConnInterface) MigrationServiceClient {
	return &migrationServiceClient{cc}
}

func (c *migrationServiceClient) TransferVolume(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[VolumeChunk, TransferAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MigrationService_ServiceDesc.Streams[0], MigrationService_TransferVolume_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[VolumeChunk, TransferAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferVolumeClient = grpc.BidiStreamingClient[VolumeChunk, TransferAck]

func (c *migrationServiceClient) TransferImageLayers(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[LayerBlob, TransferAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MigrationService_ServiceDesc.Streams[1], MigrationService_TransferImageLayers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LayerBlob, TransferAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferImageLayersClient = grpc.BidiStreamingClient[LayerBlob, TransferAck]

func (c *migrationServiceClient) GetResourceList(ctx context.Context, in *ResourceRequest, opts ...grpc.CallOption) (*ResourceList, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ResourceList)
	err := c.cc.Invoke(ctx, MigrationService_GetResourceList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationServiceClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Pong, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Pong)
	err := c.cc.Invoke(ctx, MigrationService_Ping_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *migrationServiceClient) TransferContainer(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ContainerChunk, TransferAck], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MigrationService_ServiceDesc.Streams[2], MigrationService_TransferContainer_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ContainerChunk, TransferAck]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferContainerClient = grpc.BidiStreamingClient[ContainerChunk, TransferAck]

func (c *migrationServiceClient) TransferNetwork(ctx context.Context, in *NetworkConfig, opts ...grpc.CallOption) (*TransferResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(TransferResult)
	err := c.cc.Invoke(ctx, MigrationService_TransferNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MigrationServiceServer is the server API for MigrationService service.
// All implementations must embed UnimplementedMigrationServiceServer
// for forward compatibility.
//
// MigrationService handles peer-to-peer resource migration
type MigrationServiceServer interface {
	// TransferVolume transfers volume data in chunks with checksums
	TransferVolume(grpc.BidiStreamingServer[VolumeChunk, TransferAck]) error
	// TransferImageLayers transfers image layers as blobs
	TransferImageLayers(grpc.BidiStreamingServer[LayerBlob, TransferAck]) error
	// GetResourceList retrieves list of available resources on peer
	GetResourceList(context.Context, *ResourceRequest) (*ResourceList, error)
	// Ping checks peer connectivity and latency
	Ping(context.Context, *Empty) (*Pong, error)
	// TransferContainer transfers container state and configuration
	TransferContainer(grpc.BidiStreamingServer[ContainerChunk, TransferAck]) error
	// TransferNetwork transfers network configuration
	TransferNetwork(context.Context, *NetworkConfig) (*TransferResult, error)
	mustEmbedUnimplementedMigrationServiceServer()
}

// UnimplementedMigrationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMigrationServiceServer struct{}

func (UnimplementedMigrationServiceServer) TransferVolume(grpc.BidiStreamingServer[VolumeChunk, TransferAck]) error {
	return status.Error(codes.Unimplemented, "method TransferVolume not implemented")
}
func (UnimplementedMigrationServiceServer) TransferImageLayers(grpc.BidiStreamingServer[LayerBlob, TransferAck]) error {
	return status.Error(codes.Unimplemented, "method TransferImageLayers not implemented")
}
func (UnimplementedMigrationServiceServer) GetResourceList(context.Context, *ResourceRequest) (*ResourceList, error) {
	return nil, status.Error(codes.Unimplemented, "method GetResourceList not implemented")
}
func (UnimplementedMigrationServiceServer) Ping(context.Context, *Empty) (*Pong, error) {
	return nil, status.Error(codes.Unimplemented, "method Ping not implemented")
}
func (UnimplementedMigrationServiceServer) TransferContainer(grpc.BidiStreamingServer[ContainerChunk, TransferAck]) error {
	return status.Error(codes.Unimplemented, "method TransferContainer not implemented")
}
func (UnimplementedMigrationServiceServer) TransferNetwork(context.Context, *NetworkConfig) (*TransferResult, error) {
	return nil, status.Error(codes.Unimplemented, "method TransferNetwork not implemented")
}
func (UnimplementedMigrationServiceServer) mustEmbedUnimplementedMigrationServiceServer() {}
func (UnimplementedMigrationServiceServer) testEmbeddedByValue()                          {}

// UnsafeMigrationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MigrationServiceServer will
// result in compilation errors.
type UnsafeMigrationServiceServer interface {
	mustEmbedUnimplementedMigrationServiceServer()
}

func RegisterMigrationServiceServer(s grpc.ServiceRegistrar, srv MigrationServiceServer) {
	// If the following call panics, it indicates UnimplementedMigrationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MigrationService_ServiceDesc, srv)
}

func _MigrationService_TransferVolume_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MigrationServiceServer).TransferVolume(&grpc.GenericServerStream[VolumeChunk, TransferAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferVolumeServer = grpc.BidiStreamingServer[VolumeChunk, TransferAck]

func _MigrationService_TransferImageLayers_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MigrationServiceServer).TransferImageLayers(&grpc.GenericServerStream[LayerBlob, TransferAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferImageLayersServer = grpc.BidiStreamingServer[LayerBlob, TransferAck]

func _MigrationService_GetResourceList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationServiceServer).GetResourceList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MigrationService_GetResourceList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationServiceServer).GetResourceList(ctx, req.(*ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationService_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationServiceServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MigrationService_Ping_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationServiceServer).Ping(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MigrationService_TransferContainer_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MigrationServiceServer).TransferContainer(&grpc.GenericServerStream[ContainerChunk, TransferAck]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MigrationService_TransferContainerServer = grpc.BidiStreamingServer[ContainerChunk, TransferAck]

func _MigrationService_TransferNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkConfig)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MigrationServiceServer).TransferNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MigrationService_TransferNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MigrationServiceServer).TransferNetwork(ctx, req.(*NetworkConfig))
	}
	return interceptor(ctx, in, info, handler)
}

// MigrationService_ServiceDesc is the grpc.ServiceDesc for MigrationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MigrationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migrate.MigrationService",
	HandlerType: (*MigrationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetResourceList",
			Handler:    _MigrationService_GetResourceList_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _MigrationService_Ping_Handler,
		},
		{
			MethodName: "TransferNetwork",
			Handler:    _MigrationService_TransferNetwork_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TransferVolume",
			Handler:       _MigrationService_TransferVolume_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TransferImageLayers",
			Handler:       _MigrationService_TransferImageLayers_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "TransferContainer",
			Handler:       _MigrationService_TransferContainer_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/migrate.proto",
}

const (
	MasterService_RegisterWorker_FullMethodName  = "/migrate.MasterService/RegisterWorker"
	MasterService_WorkerStream_FullMethodName    = "/migrate.MasterService/WorkerStream"
	MasterService_ReportResources_FullMethodName = "/migrate.MasterService/ReportResources"
)

// MasterServiceClient is the client API for MasterService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// MasterService - Workers connect to this on the master node
type MasterServiceClient interface {
	// RegisterWorker registers a new worker with the master
	RegisterWorker(ctx context.Context, in *WorkerRegistration, opts ...grpc.CallOption) (*RegistrationResponse, error)
	// WorkerStream maintains bidirectional communication for heartbeats and commands
	WorkerStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WorkerMessage, MasterCommand], error)
	// ReportResources reports worker's Docker resource inventory
	ReportResources(ctx context.Context, in *ResourceInventory, opts ...grpc.CallOption) (*AckResponse, error)
}

type masterServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewMasterServiceClient(cc grpc.ClientConnInterface) MasterServiceClient {
	return &masterServiceClient{cc}
}

func (c *masterServiceClient) RegisterWorker(ctx context.Context, in *WorkerRegistration, opts ...grpc.CallOption) (*RegistrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RegistrationResponse)
	err := c.cc.Invoke(ctx, MasterService_RegisterWorker_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *masterServiceClient) WorkerStream(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[WorkerMessage, MasterCommand], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &MasterService_ServiceDesc.Streams[0], MasterService_WorkerStream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[WorkerMessage, MasterCommand]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MasterService_WorkerStreamClient = grpc.BidiStreamingClient[WorkerMessage, MasterCommand]

func (c *masterServiceClient) ReportResources(ctx context.Context, in *ResourceInventory, opts ...grpc.CallOption) (*AckResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AckResponse)
	err := c.cc.Invoke(ctx, MasterService_ReportResources_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MasterServiceServer is the server API for MasterService service.
// All implementations must embed UnimplementedMasterServiceServer
// for forward compatibility.
//
// MasterService - Workers connect to this on the master node
type MasterServiceServer interface {
	// RegisterWorker registers a new worker with the master
	RegisterWorker(context.Context, *WorkerRegistration) (*RegistrationResponse, error)
	// WorkerStream maintains bidirectional communication for heartbeats and commands
	WorkerStream(grpc.BidiStreamingServer[WorkerMessage, MasterCommand]) error
	// ReportResources reports worker's Docker resource inventory
	ReportResources(context.Context, *ResourceInventory) (*AckResponse, error)
	mustEmbedUnimplementedMasterServiceServer()
}

// UnimplementedMasterServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedMasterServiceServer struct{}

func (UnimplementedMasterServiceServer) RegisterWorker(context.Context, *WorkerRegistration) (*RegistrationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method RegisterWorker not implemented")
}
func (UnimplementedMasterServiceServer) WorkerStream(grpc.BidiStreamingServer[WorkerMessage, MasterCommand]) error {
	return status.Error(codes.Unimplemented, "method WorkerStream not implemented")
}
func (UnimplementedMasterServiceServer) ReportResources(context.Context, *ResourceInventory) (*AckResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ReportResources not implemented")
}
func (UnimplementedMasterServiceServer) mustEmbedUnimplementedMasterServiceServer() {}
func (UnimplementedMasterServiceServer) testEmbeddedByValue()                       {}

// UnsafeMasterServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MasterServiceServer will
// result in compilation errors.
type UnsafeMasterServiceServer interface {
	mustEmbedUnimplementedMasterServiceServer()
}

func RegisterMasterServiceServer(s grpc.ServiceRegistrar, srv MasterServiceServer) {
	// If the following call panics, it indicates UnimplementedMasterServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&MasterService_ServiceDesc, srv)
}

func _MasterService_RegisterWorker_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkerRegistration)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).RegisterWorker(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_RegisterWorker_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).RegisterWorker(ctx, req.(*WorkerRegistration))
	}
	return interceptor(ctx, in, info, handler)
}

func _MasterService_WorkerStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(MasterServiceServer).WorkerStream(&grpc.GenericServerStream[WorkerMessage, MasterCommand]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type MasterService_WorkerStreamServer = grpc.BidiStreamingServer[WorkerMessage, MasterCommand]

func _MasterService_ReportResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceInventory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MasterServiceServer).ReportResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MasterService_ReportResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MasterServiceServer).ReportResources(ctx, req.(*ResourceInventory))
	}
	return interceptor(ctx, in, info, handler)
}

// MasterService_ServiceDesc is the grpc.ServiceDesc for MasterService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MasterService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migrate.MasterService",
	HandlerType: (*MasterServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterWorker",
			Handler:    _MasterService_RegisterWorker_Handler,
		},
		{
			MethodName: "ReportResources",
			Handler:    _MasterService_ReportResources_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "WorkerStream",
			Handler:       _MasterService_WorkerStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/migrate.proto",
}

const (
	WorkerService_InitiateMigration_FullMethodName = "/migrate.WorkerService/InitiateMigration"
	WorkerService_AcceptMigration_FullMethodName   = "/migrate.WorkerService/AcceptMigration"
	WorkerService_HealthCheck_FullMethodName       = "/migrate.WorkerService/HealthCheck"
	WorkerService_CancelMigration_FullMethodName   = "/migrate.WorkerService/CancelMigration"
)

// WorkerServiceClient is the client API for WorkerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// WorkerService - Master calls workers for direct commands
type WorkerServiceClient interface {
	// InitiateMigration instructs worker to start a migration as source
	InitiateMigration(ctx context.Context, in *MigrationRequest, opts ...grpc.CallOption) (*MigrationResponse, error)
	// AcceptMigration instructs worker to accept incoming migration as target
	AcceptMigration(ctx context.Context, in *AcceptMigrationRequest, opts ...grpc.CallOption) (*AcceptMigrationResponse, error)
	// HealthCheck verifies worker is healthy and responsive
	HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthResponse, error)
	// CancelMigration cancels an in-progress migration
	CancelMigration(ctx context.Context, in *CancelMigrationRequest, opts ...grpc.CallOption) (*CancelMigrationResponse, error)
}

type workerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewWorkerServiceClient(cc grpc.ClientConnInterface) WorkerServiceClient {
	return &workerServiceClient{cc}
}

func (c *workerServiceClient) InitiateMigration(ctx context.Context, in *MigrationRequest, opts ...grpc.CallOption) (*MigrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(MigrationResponse)
	err := c.cc.Invoke(ctx, WorkerService_InitiateMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) AcceptMigration(ctx context.Context, in *AcceptMigrationRequest, opts ...grpc.CallOption) (*AcceptMigrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(AcceptMigrationResponse)
	err := c.cc.Invoke(ctx, WorkerService_AcceptMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) HealthCheck(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*HealthResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(HealthResponse)
	err := c.cc.Invoke(ctx, WorkerService_HealthCheck_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *workerServiceClient) CancelMigration(ctx context.Context, in *CancelMigrationRequest, opts ...grpc.CallOption) (*CancelMigrationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CancelMigrationResponse)
	err := c.cc.Invoke(ctx, WorkerService_CancelMigration_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WorkerServiceServer is the server API for WorkerService service.
// All implementations must embed UnimplementedWorkerServiceServer
// for forward compatibility.
//
// WorkerService - Master calls workers for direct commands
type WorkerServiceServer interface {
	// InitiateMigration instructs worker to start a migration as source
	InitiateMigration(context.Context, *MigrationRequest) (*MigrationResponse, error)
	// AcceptMigration instructs worker to accept incoming migration as target
	AcceptMigration(context.Context, *AcceptMigrationRequest) (*AcceptMigrationResponse, error)
	// HealthCheck verifies worker is healthy and responsive
	HealthCheck(context.Context, *Empty) (*HealthResponse, error)
	// CancelMigration cancels an in-progress migration
	CancelMigration(context.Context, *CancelMigrationRequest) (*CancelMigrationResponse, error)
	mustEmbedUnimplementedWorkerServiceServer()
}

// UnimplementedWorkerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedWorkerServiceServer struct{}

func (UnimplementedWorkerServiceServer) InitiateMigration(context.Context, *MigrationRequest) (*MigrationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method InitiateMigration not implemented")
}
func (UnimplementedWorkerServiceServer) AcceptMigration(context.Context, *AcceptMigrationRequest) (*AcceptMigrationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptMigration not implemented")
}
func (UnimplementedWorkerServiceServer) HealthCheck(context.Context, *Empty) (*HealthResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HealthCheck not implemented")
}
func (UnimplementedWorkerServiceServer) CancelMigration(context.Context, *CancelMigrationRequest) (*CancelMigrationResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelMigration not implemented")
}
func (UnimplementedWorkerServiceServer) mustEmbedUnimplementedWorkerServiceServer() {}
func (UnimplementedWorkerServiceServer) testEmbeddedByValue()                       {}

// UnsafeWorkerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WorkerServiceServer will
// result in compilation errors.
type UnsafeWorkerServiceServer interface {
	mustEmbedUnimplementedWorkerServiceServer()
}

func RegisterWorkerServiceServer(s grpc.ServiceRegistrar, srv WorkerServiceServer) {
	// If the following call panics, it indicates UnimplementedWorkerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&WorkerService_ServiceDesc, srv)
}

func _WorkerService_InitiateMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).InitiateMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_InitiateMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).InitiateMigration(ctx, req.(*MigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_AcceptMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).AcceptMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_AcceptMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).AcceptMigration(ctx, req.(*AcceptMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_HealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).HealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_HealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).HealthCheck(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _WorkerService_CancelMigration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelMigrationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WorkerServiceServer).CancelMigration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WorkerService_CancelMigration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WorkerServiceServer).CancelMigration(ctx, req.(*CancelMigrationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WorkerService_ServiceDesc is the grpc.ServiceDesc for WorkerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WorkerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migrate.WorkerService",
	HandlerType: (*WorkerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InitiateMigration",
			Handler:    _WorkerService_InitiateMigration_Handler,
		},
		{
			MethodName: "AcceptMigration",
			Handler:    _WorkerService_AcceptMigration_Handler,
		},
		{
			MethodName: "HealthCheck",
			Handler:    _WorkerService_HealthCheck_Handler,
		},
		{
			MethodName: "CancelMigration",
			Handler:    _WorkerService_CancelMigration_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/migrate.proto",
}

const (
	ProxyService_OpenProxyChannel_FullMethodName = "/migrate.ProxyService/OpenProxyChannel"
)

// ProxyServiceClient is the client API for ProxyService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ProxyService allows master to relay data between workers that cannot
// directly connect to each other (e.g., behind NAT/firewalls)
type ProxyServiceClient interface {
	// OpenProxyChannel opens a bidirectional stream for relaying migration data
	OpenProxyChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProxyData, ProxyData], error)
}

type proxyServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProxyServiceClient(cc grpc.ClientConnInterface) ProxyServiceClient {
	return &proxyServiceClient{cc}
}

func (c *proxyServiceClient) OpenProxyChannel(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[ProxyData, ProxyData], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ProxyService_ServiceDesc.Streams[0], ProxyService_OpenProxyChannel_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ProxyData, ProxyData]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ProxyService_OpenProxyChannelClient = grpc.BidiStreamingClient[ProxyData, ProxyData]

// ProxyServiceServer is the server API for ProxyService service.
// All implementations must embed UnimplementedProxyServiceServer
// for forward compatibility.
//
// ProxyService allows master to relay data between workers that cannot
// directly connect to each other (e.g., behind NAT/firewalls)
type ProxyServiceServer interface {
	// OpenProxyChannel opens a bidirectional stream for relaying migration data
	OpenProxyChannel(grpc.BidiStreamingServer[ProxyData, ProxyData]) error
	mustEmbedUnimplementedProxyServiceServer()
}

// UnimplementedProxyServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProxyServiceServer struct{}

func (UnimplementedProxyServiceServer) OpenProxyChannel(grpc.BidiStreamingServer[ProxyData, ProxyData]) error {
	return status.Error(codes.Unimplemented, "method OpenProxyChannel not implemented")
}
func (UnimplementedProxyServiceServer) mustEmbedUnimplementedProxyServiceServer() {}
func (UnimplementedProxyServiceServer) testEmbeddedByValue()                      {}

// UnsafeProxyServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProxyServiceServer will
// result in compilation errors.
type UnsafeProxyServiceServer interface {
	mustEmbedUnimplementedProxyServiceServer()
}

func RegisterProxyServiceServer(s grpc.ServiceRegistrar, srv ProxyServiceServer) {
	// If the following call panics, it indicates UnimplementedProxyServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProxyService_ServiceDesc, srv)
}

func _ProxyService_OpenProxyChannel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(ProxyServiceServer).OpenProxyChannel(&grpc.GenericServerStream[ProxyData, ProxyData]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ProxyService_OpenProxyChannelServer = grpc.BidiStreamingServer[ProxyData, ProxyData]

// ProxyService_ServiceDesc is the grpc.ServiceDesc for ProxyService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProxyService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migrate.ProxyService",
	HandlerType: (*ProxyServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "OpenProxyChannel",
			Handler:       _ProxyService_OpenProxyChannel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "proto/migrate.proto",
}
